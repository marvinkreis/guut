Below, you are going to find:
- A python function containing a bug.
- The dependencies of the function.
- A diff containing the fix for the bug.

You are going to use the scientific method to debug the problem.
 by drawing hypotheses, verifying them through experiments and drawing conclusions. Once you fully understand the bug, you will be asked to write a unit test that can detect it.

Here is an explanation of the scientific method for debugging:


Your job is to provide a hypothesis, a prediction and an experiment in your response.
You will then be given the experiment's output.
Then you respond with a conclusion, and, if you choose to continue, a new hypothesis, prediction and experiment.

1. Hypothesis
    - Hypotheses provide an explanation for the buggy behavior or provide key insights that will help you construct an explanation for the buggy behavior.
    - Hypotheses are the key aspect of this approach, and should be detailed and written with care.
    - Hypotheses should build upon all previous information.
    - Repeating hypothesis is thus strongly discouraged.

    - Example hypothesis 1: "Given that [information], the method is [overall erroneous behavior]. Specifically, in the buggy version of `example.py`, `c > b` on line 12 never evaluates to True, so the body of the if-condition is never executed. Because of this, [erroneous behavior].
    - Example hypothesis 2: "As the previous hypothesis was rejected, we now that the body of the if-condition is sometimes executed. Seeing that the fix changes `c > b` to `c >= b`, perhaps the loop has an off-by-one error instead, this means that [desired behavior], but instead [erroneous behavior]."
    - Example hypothesis 3: "Because the previous hypothesis was supported, the code [information]. Therefore, calling the function with an empty list will [erroneous behavior]."
    - Example hypothesis 4: "It seems the previous experiment ended in an error. Perhaps the experiment can be refined by [new experiment]."

2. Prediction
    - Predictions describe a specific value or symptom that would be observed if the hypothesis is correct.
    - Depending on the hypothesis, one may make the prediction that:
        - A test would have different output when ran on the buggy version and the fixed version.
        - A debugger would show different variable values or behavior when ran on the buggy version and the fixed version.

    - Example prediction 1: If I use the debugger to stop at line 13, only the fixed version will stop and print, since the line will never be executed in the buggy version.
    - Example prediction 2: If I let the debugger stop at line 24 and print [expr], while given the input and its intended role indicates that its value should be [correct value], it will instead be [erroneous value].
    - Example prediction 3: If I call the function with [bug-revealing input] as input, then the buggy version will return [erroneous output], while the fixed version will return [correct output].
    - Example prediction 4: When the input to the contains [bug-revealing input], then the buggy version will be caught in an infinite loop, while the fixed version will return normally.

3. Experiment
    - Since predictions can't stand on their own, experiments provide a way to verify or falsify your predictions.
    - Each experiment will contain a test, which calls the function under test.
    - The test is ran against both the buggy and the correct implementation, and you are given the results to draw a conclusion from.
    - Additionally, you can provide a specific python debugger (pdb) script that would check whether the prediction made is true. If the debugger script is present, the tests are additionally executed in the debugger with your script.

    - Example experiment 1 (test code):
        ```python
            result = example.foo([1,2,3])
            assert 4 not in result
        ```
    - Example experiment 2 (pdb script):
        ```debugger
            b example.py:12
            c
            print [expr]
        ```

4. Observation
    - After the experiment concludes, you are given the outputs to draw a conclusion.
    - The conclusion is a judgement whether the hypothesis is true based on the observation.
    - Add <DEBUGGING DONE> when you fully understood the bug and gathered enough information to create a test to detect it.

    - Example observation 1: The hypothesis is supported since the test outputs [erroneous output] for the buggy version.
    - Example observation 2: The hypothesis is rejected, because [reason].
    - Example observation 3: The hypothesis is undecided due to an error in the experiment.



Debugger (pdb) explanation:
    - The debugger will start in a suspended state on the first line.
    - Available debugger commands are:
        - Break:
            - Syntax: b(reak) filename:lineno [, condition]
            - Description: Sets a breakpoint at the given position. If a condition is given, the breakpoint will only stop the execution if the condition evaluates to true.
            - Example 1: b example.py:7
            - Example 1: b program.py:26, len(nodes) == 2
        - Next:
            - Syntax: n(ext)
            - Description: Continues execution until either the next line or the end of the function is reached.
        - Until:
            - Syntax: unt(il) lineno
            - Description: Continues execution until the line with the number lineno is reached.
        - Continue:
            - Syntax: c(continue) [lineno]
            - Description: Continue execution until the next breakpoint is reached.
        - Print:
            - Syntax: p(rint) expression
            - Evaluates expression in the current context and prints its value.





TODO:
- verifying_expr is a big part of the experiment setup, because it forces the LLM to produce an expression to test, and forces it to only verify it if it evaluates to True. Otherwise, the LLM can just state that the experiment succeeded.
- encourage falsifying hypotheses
- "We will look for ... in your output to recognize test cases and debugger scripts. If your response does not contain ..."
- explain the procedure: Supply hypothesis + prediction + experiment -> get output -> supply conclusion + hypothesis + prediction + experiment
